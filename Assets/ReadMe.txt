PENSIERI DELLO SVILUPPATORE (Note utili per capire cos'ho fatto)

La parte più complessa e sostanziosa di questo progetto è la FSM. All'inizio doveva essere leggermente più complessa di quella vista durante il corso, poi la cosa mi è sfuggita di mano. Mi ha preso a tal punto che mi ci sono voluti 12 giorni per finirla (in teoria senza bug).

Sostanzialmente mi sono ispirato ad un sistema decisionale simile a quello che succede in natura. Per decidere lo stato mi servono degli input dall'ambiente o da me stesso, e per prendere questi mi servono dei sensi(input esterni) o delle funzioni interne apposta(input interni).
I sensi che ho implementato sono la vista e l'udito, entrambi riferiscono ad uno script "SenseBrain" che elabora gli input in base all'importanza (per esempio pesi dati da un'ordine su una lista o allo scorrere del tempo). I risultati saranno o un Character o/e un punto Vector3. Queste informazioni possono essere prese dal controller della FSM per decidere quale stato usare per quel momento o essere bypassate da un input interno più rilevante (per esempio una transizione dall'anyState).

L'udito è un senso passivo, perciò deve registrare le informazioni che gli vengono passate, non cercarle attivamente dall'ambiente. Quando c'è un suono da sentire, lo script Noise chiama tutti i metodi Listen di EnemyHear in n certo raggio e gli passa delle informazioni (degno di nota è l'intensità).
La vista è un senso attivo (ha la priorità sull'udito) e l'ho strutturata in modo leggermente diverso dal solito. Non volevo usare una serie di Raycast (o Linecast) per cercare tutti i target possibili nel cono di visione, mi sono venuti in mente casi in cui avrei potuto perderne qualcuno o rischiare di calcolare lo stesso target 2 o più volte. Ho optato per filtrare i colliders di un OverlapSphere attraverso un Linecast per sapere se erano direttamente visibili e ho filtrato i restanti per il coseno.
L'estensione dei sensi cambia in base allo stato in cui ci si trova in quel momento. Se non hai un target definito allora non sei concentrato su qualcosa perciò hai un campo visivo più ampio, ma ridotto. Se stai inseguendo qualcuno allora non togli lo sguardo dal bersaglio, il campo visivo è più ridotto, ma più profondo. Anche qui mi sono ispirato alla natura (differenze tra i sensi delle prede e dei predatori).

Un altro aspetto fondamentale di questa FSM (o di questo gioco in sé) è che, a inizio partita, ogni Enemy non sa distinguere il Player o gli Enemy tra tutti i Character in scena, e, man mano che si incontrano, si passano informazioni su chi sono e su chi hanno incontrato. Per dare profondità allo scambio di informazioni, ogni Enemy ha un codice univoco che ogni Enemy può verificare attraverso il Singleton per sapere se è un codice valido. L'unico a non avere un codice è il Player. Quando un Enemy chatta con il Player compare un'interfaccia utente domanda-risposta. Le domande e le risposte non hanno un sistema di verifica e possono essere scritte tramite degli ScriptableObject. L'ultima domanda è quella fondamentale: viene chiesto al Player di fornire un codice. Qui il Player sbaglierà (ogni 10 Enemy in scena sono 1% in più di fare giusto). Sicuramente ci sono diverse meccaniche da rivedere per rendere l'esperienza più … sensata, ma era più per sperimentare.

Per limitare e rendere più controllato l'uso di metodi pubblici, in un'ottica futura di lavoro di gruppo, ho cercato di limitarne l'accesso inserendo degli if che richiedono parametri già noti, così che solo certi componenti possano accedere a tali funzioni. Dovrei studiare meglio questi sistemi di sicurezza (magari una cosa del tipo chiave pubblica e chiave privata). Inoltre vorrei far notare la funzione "SwitchOffAllEnemy" nel Singleton degli Enemy. Solo un Enemy che abbia preso il Player può attivare questo metodo.

Vorrei ottimizzare meglio certi stati della FSM, ma mi manca il tempo e devo finire il resto.